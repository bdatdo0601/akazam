{"version":3,"sources":["../../../src/db/models/location.js"],"names":["debug","require","EMPTY_ADDRESS","address","city","state","zipCode","locationSchema","Schema","name","type","String","unique","dropDups","required","country","lat","Number","long","convertAddress","parsedAddress","addressParser","parseAddress","number","prefix","street","zip","Location","Model","createNewLocation","rawData","convertedAddress","data","newLocation","newLocationDocument","save","error","Error","getLocationFromName","location","findOne","updateLocationByName","updatedRawData","shouldCreateNew","updateOne","upsert","deleteLocationByName","deleteOne","mongoose","model"],"mappings":"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","sourcesContent":["/**\n * Location Model\n *\n * hold a real world's location in a format that can be easily retrieve, search, etc\n */\nimport mongoose, { Schema, Model } from \"mongoose\";\nimport addressParser from \"parse-address\";\n\nconst debug = require(\"debug\")(\"Akazam:Location\");\n\nconst EMPTY_ADDRESS = {\n    address: \"\",\n    city: \"\",\n    state: \"\",\n    zipCode: \"\",\n};\n\nconst locationSchema = new Schema({\n    name: {\n        type: String,\n        unique: true,\n        dropDups: true,\n        required: [true, \"Location needs name\"],\n    },\n    address: String,\n    zipCode: String,\n    state: String,\n    city: String,\n    country: String,\n    lat: Number,\n    long: Number,\n});\n\n/**\n * Converting address\n *\n * breaking input address into multiple part\n * (e.g: 123 A B Street, C, AB 12345 --> address: 123 A B St, city: C, state: AB, zipCode: 12345)\n *\n * @param {*} address original address\n */\nconst convertAddress = address => {\n    const parsedAddress = addressParser.parseAddress(address);\n    if (!parsedAddress) return null;\n    return {\n        address: `${parsedAddress.number} ${parsedAddress.prefix ? parsedAddress.prefix + \" \" : \"\"}${\n            parsedAddress.street\n        } ${parsedAddress.type}`,\n        city: parsedAddress.city,\n        state: parsedAddress.state,\n        zipCode: parsedAddress.zip,\n    };\n};\n\nclass Location extends Model {\n    /**\n     * Inserting new location into database\n     *\n     * @param {*} rawData data to be inserted\n     */\n    static async createNewLocation(rawData) {\n        try {\n            const convertedAddress = convertAddress(rawData.address);\n            const data = convertedAddress ? { ...rawData, ...convertedAddress } : rawData;\n            const newLocation = new Location(data);\n            const newLocationDocument = await newLocation.save();\n            return newLocationDocument;\n        } catch (error) {\n            debug(error);\n            throw new Error(\"cannot create new location\");\n        }\n    }\n    /**\n     * Get a location from database from name\n     *\n     * @param {*} name name of the retriving location\n     */\n    static async getLocationFromName(name) {\n        try {\n            if (!name) throw new Error(\"Invalid Inputs\");\n            const location = await this.findOne({ name });\n            return location;\n        } catch (error) {\n            debug(error);\n            throw new Error(\"Could not initiate searching process\");\n        }\n    }\n    /**\n     * Update a location with new data\n     *\n     * @param {*} name name of the location that should be updated\n     * @param {*} updatedRawData updated information\n     * @param {*} shouldCreateNew determine if an input is non-existed, should the data be created\n     */\n    static async updateLocationByName(name, updatedRawData, shouldCreateNew = true) {\n        try {\n            if (!name) throw new Error(\"Invalid Inputs\");\n            const convertedAddress = convertAddress(updatedRawData.address);\n            const data = convertedAddress\n                ? { ...updatedRawData, ...EMPTY_ADDRESS, ...convertedAddress }\n                : updatedRawData;\n            const location = await this.updateOne({ name }, data, { upsert: shouldCreateNew });\n            return location;\n        } catch (error) {\n            debug(error);\n            throw new Error(\"Could not initiate searching process\");\n        }\n    }\n    /**\n     * Delete a given location in database\n     *\n     * @param {*} name name of the deleted location\n     */\n    static async deleteLocationByName(name) {\n        try {\n            if (!name) throw new Error(\"Invalid Inputs\");\n            await this.deleteOne({ name });\n            return true;\n        } catch (error) {\n            debug(error);\n            throw new Error(\"Could not initiate searching process\");\n        }\n    }\n}\n\nexport default mongoose.model(Location, locationSchema, \"Location\");\n"],"file":"location.js"}